#![deny(rust_2018_idioms, clippy::all)]
#![warn(clippy::nursery)] // Don't deny, as there may be unknown bugs.
#![allow(intra_doc_link_resolution_failure)]

mod scope;

use derive_builder::Builder;
use itertools::Itertools;
use lazy_static::lazy_static;
use reqwest::{header::USER_AGENT, Client, Url, UrlError};
pub use scope::Scope;
use serde::Deserialize;
use std::time::{Duration, SystemTime};

lazy_static! {
    static ref CLIENT: Client = Client::builder().gzip(true).build().unwrap();
}

/// Returns a globally unique identifier.
/// Specifically, v4, which is not based on any input factors.
pub fn guid() -> String {
    uuid::Uuid::new_v4().to_string()
}

/// A Reddit configuration.
/// Used to create `User`s.
#[derive(Builder, Debug)]
pub struct Reddit<'a> {
    redirect_uri: &'a str,
    user_agent:   &'a str,
    client_id:    &'a str,
    secret:       &'a str,
    permanent:    bool,
    scopes:       &'a [Scope],
}

/// A Reddit User,
/// containing the tokens necessary to make requests.
#[derive(Builder, Debug)]
pub struct User<'a> {
    reddit_instance: &'a Reddit<'a>,
    refresh_token:   String,
    access_token:    String,
    expires_at:      SystemTime,
}

/// Builder and getters
impl Reddit<'_> {
    /// Return a `RedditBuilder`.
    /// The same as calling `RedditBuilder::default()`.
    pub fn builder() -> RedditBuilder<'static> {
        RedditBuilder::default()
    }

    /// The URI to redirect the client to after authentication.
    pub const fn redirect_uri(&self) -> &str {
        self.redirect_uri
    }

    /// The user agent to send alongside each request.
    pub const fn user_agent(&self) -> &str {
        self.user_agent
    }

    /// The client ID generated by Reddit.
    pub const fn client_id(&self) -> &str {
        self.client_id
    }

    /// The app secret generated by Reddit.
    pub const fn secret(&self) -> &str {
        self.secret
    }

    /// Whether permission requests are temporary or permanent.
    pub const fn permanent(&self) -> bool {
        self.permanent
    }

    /// Get the requested scopes.
    pub const fn scopes(&self) -> &[Scope] {
        self.scopes
    }
}

// Getters
impl User<'_> {
    /// Return a `UserBuilder`.
    /// The same as calling `UserBuilder::default()`.
    pub fn builder() -> UserBuilder<'static> {
        UserBuilder::default()
    }

    /// Get the refresh token of the user.
    pub const fn refresh_token(&self) -> &String {
        &self.refresh_token
    }

    /// Get the access token of the user,
    /// fetching a new one from Reddit if necessary.
    pub fn access_token(&mut self) -> &String {
        // Refresh the access token if it's expired.
        if self.expires_at < SystemTime::now() {
            #[derive(Deserialize)]
            struct APIReturnType {
                access_token: String,
                expires_in:   u64,
            }

            let response: APIReturnType = CLIENT
                .post("https://ssl.reddit.com/api/v1/access_token")
                .basic_auth(
                    self.reddit_instance.client_id,
                    Some(self.reddit_instance.secret),
                )
                .form(&[
                    ("grant_type", "refresh_token"),
                    ("refresh_token", &self.refresh_token),
                ])
                .send()
                .unwrap()
                .json()
                .unwrap();

            self.access_token = response.access_token;
            self.expires_at = SystemTime::now() + Duration::from_secs(response.expires_in);
        }

        &self.access_token
    }

    /// When the access token is due to expire.
    pub const fn expires_at(&self) -> &SystemTime {
        &self.expires_at
    }
}

impl<'a> Reddit<'a> {
    /// Get a URL to send the user to for authentication.
    pub fn get_auth_url(&self, callback: &str) -> Result<String, UrlError> {
        Ok(Url::parse_with_params(
            "https://ssl.reddit.com/api/v1/authorize",
            &[
                ("response_type", "code"),
                ("client_id", self.client_id),
                ("state", callback),
                ("redirect_uri", self.redirect_uri),
                (
                    "duration",
                    if self.permanent {
                        "permanent"
                    } else {
                        "temporary"
                    },
                ),
                ("scope", &self.scopes().iter().join(" ")),
            ],
        )?
        .into_string())
    }

    /// Given a code, obtain a refresh token from Reddit.
    pub fn obtain_refresh_token(&self, code: &str) -> reqwest::Result<User<'_>> {
        #[derive(Deserialize)]
        struct APIReturnType {
            access_token:  String,
            expires_in:    u64,
            refresh_token: Option<String>,
        }

        let data: APIReturnType = CLIENT
            .post("https://ssl.reddit.com/api/v1/access_token")
            .basic_auth(self.client_id, Some(self.secret))
            .form(&[
                ("grant_type", "authorization_code"),
                ("code", code),
                ("redirect_uri", self.redirect_uri),
            ])
            .send()?
            .json()?;

        Ok(User {
            reddit_instance: self,
            refresh_token:   data.refresh_token.unwrap(),
            access_token:    data.access_token,
            expires_at:      SystemTime::now() + Duration::from_secs(data.expires_in),
        })
    }
}

/// Given the endpoint's path, return the full URL.
fn endpoint(path: &str) -> String {
    format!("https://oauth.reddit.com{}", path)
}

/// Endpoints
impl User<'_> {
    fn me(&mut self) -> reqwest::Result<reqwest::Response> {
        CLIENT
            .get(&endpoint("/api/v1/me"))
            .header(USER_AGENT, self.reddit_instance.user_agent)
            .bearer_auth(self.access_token())
            .send()
    }

    fn prefs(&mut self) -> reqwest::Result<reqwest::Response> {
        CLIENT
            .get(&endpoint("/api/v1/me/prefs"))
            .header(USER_AGENT, self.reddit_instance.user_agent)
            .bearer_auth(self.access_token())
            .send()
    }

    fn submit(
        &mut self,
        subreddit: &str,
        title: &str,
        text: Option<&str>,
    ) -> reqwest::Result<reqwest::Response> {
        CLIENT
            .post(&endpoint("/api/submit"))
            .header(USER_AGENT, self.reddit_instance.user_agent)
            .bearer_auth(self.access_token())
            .form(&[
                ("kind", "self"),
                ("api_type", "json"),
                ("extensions", "json"),
                ("sendreplies", "false"),
                ("sr", subreddit),
                ("title", title),
                ("text", text.unwrap_or_default()),
            ])
            .send()
    }

    fn edit(&mut self, thing_id: &str, text: &str) -> reqwest::Result<reqwest::Response> {
        CLIENT
            .post(&endpoint("/api/editusertext"))
            .header(USER_AGENT, self.reddit_instance.user_agent)
            .bearer_auth(self.access_token())
            .form(&[("api_type", "json"), ("thing_id", thing_id), ("text", text)])
            .send()
    }

    fn approve_internal(&mut self, thing_id: &str) -> reqwest::Result<reqwest::Response> {
        CLIENT
            .post(&endpoint("/api/approve"))
            .header(USER_AGENT, self.reddit_instance.user_agent)
            .bearer_auth(self.access_token())
            .form(&[("id", thing_id)])
            .send()
    }

    fn set_sticky_internal(
        &mut self,
        thing_id: &str,
        state: bool,
    ) -> reqwest::Result<reqwest::Response> {
        CLIENT
            .post(&endpoint("/api/set_subreddit_sticky"))
            .header(USER_AGENT, self.reddit_instance.user_agent)
            .bearer_auth(self.access_token())
            .form(&[
                ("api_type", "json"),
                ("id", thing_id),
                ("state", &state.to_string()),
            ])
            .send()
    }
}

/// Methods that use endpoints
impl User<'_> {
    /// Get a user's username on Reddit.
    pub fn username(&mut self) -> reqwest::Result<String> {
        // We may use the `is_mod` field in the future
        // to automatically determine if the user is a moderator
        // of a specific subreddit
        #[derive(Deserialize)]
        struct APIReturnType {
            name: String,
            #[allow(unused)]
            is_mod: bool,
        }

        Ok(self.me()?.json::<APIReturnType>()?.name)
    }

    /// Get a user's language preference.
    pub fn lang(&mut self) -> reqwest::Result<String> {
        #[derive(Deserialize)]
        struct APIReturnType {
            lang: String,
        }

        Ok(self.prefs()?.json::<APIReturnType>()?.lang)
    }

    /// Submit a post on Reddit with a given title and body.
    /// Returns the `thing_id`.
    pub fn submit_self_post(
        &mut self,
        subreddit: &str,
        title: &str,
        text: Option<&str>,
    ) -> reqwest::Result<String> {
        Ok(self
            .submit(subreddit, title, text)?
            .json::<serde_json::Value>()
            .unwrap()
            .get("json")
            .unwrap()
            .get("data")
            .unwrap()
            .get("id")
            .unwrap()
            .to_string())
    }

    /// Edit an existing thread on Reddit.
    pub fn edit_self_post(&mut self, thing_id: &str, text: &str) -> reqwest::Result<()> {
        self.edit(thing_id, text).map(|_| ())
    }

    /// Approve a thread on Reddit.
    pub fn approve(&mut self, thing_id: &str) -> reqwest::Result<()> {
        self.approve_internal(thing_id).map(|_| ())
    }

    /// Sticky or unsticky a thread on Reddit.
    pub fn set_sticky(&mut self, thing_id: &str, state: bool) -> reqwest::Result<()> {
        self.set_sticky_internal(thing_id, state).map(|_| ())
    }
}
