#![deny(rust_2018_idioms, clippy::all, unsafe_code)]
#![warn(clippy::nursery)]

mod scope;

use derive_builder::Builder;
use getset::Getters;
use itertools::Itertools;
use once_cell::sync::Lazy;
use reqwest::{header::USER_AGENT, Client, Url, UrlError};
pub use scope::Scope;
use serde::Deserialize;
use std::time::{Duration, SystemTime};

static CLIENT: Lazy<Client> = Lazy::new(|| Client::builder().gzip(true).build().unwrap());

/// A Reddit configuration.
/// Used to create `User`s.
#[derive(Builder, Debug, Getters)]
#[get = "pub"]
pub struct Reddit<'a> {
    /// The URI to redirect the client to after authentication.
    redirect_uri: &'a str,

    /// The user agent to send alongside each request.
    user_agent: &'a str,

    /// The client ID generated by Reddit.
    client_id: &'a str,

    /// The app secret generated by Reddit.
    secret: &'a str,

    /// Whether permission requests are temporary or permanent.
    permanent: bool,

    /// Requested scopes.
    scopes: &'a [Scope],
}

/// A Reddit User,
/// containing the tokens necessary to make requests.
#[derive(Builder, Debug, Getters)]
pub struct User<'a> {
    reddit_instance: &'a Reddit<'a>,

    /// Refresh token of the user.
    #[get = "pub"]
    refresh_token: String,

    access_token: String,

    /// When the access token is due to expire.
    #[get = "pub"]
    expires_at: SystemTime,
}

impl Reddit<'_> {
    /// Return a `RedditBuilder`.
    /// The same as calling `RedditBuilder::default()`.
    pub fn builder() -> RedditBuilder<'static> {
        RedditBuilder::default()
    }
}

/// Helper to hide the fact that we need `Deserialize`.
/// If Rust ever (re)gains structural types,
/// we can do away with this entirely.
macro_rules! ApiReturnType {
    ($($ident:ident: $type:ty),* $(,)?) => {
        #[derive(Deserialize)]
        struct ApiReturnType {
            $($ident: $type),*
        }
    };
}

// Getters
impl User<'_> {
    /// Return a `UserBuilder`.
    /// The same as calling `UserBuilder::default()`.
    pub fn builder() -> UserBuilder<'static> {
        UserBuilder::default()
    }

    /// Get the access token of the user,
    /// fetching a new one from Reddit if necessary.
    pub fn access_token(&mut self) -> &String {
        // Refresh the access token if it's expired.
        if self.expires_at < SystemTime::now() {
            ApiReturnType! {
                access_token: String,
                expires_in: u64,
            };

            let response: ApiReturnType = CLIENT
                .post("https://ssl.reddit.com/api/v1/access_token")
                .basic_auth(
                    self.reddit_instance.client_id,
                    Some(self.reddit_instance.secret),
                )
                .form(&[
                    ("grant_type", "refresh_token"),
                    ("refresh_token", &self.refresh_token),
                ])
                .send()
                .unwrap()
                .json()
                .unwrap();

            self.access_token = response.access_token;
            self.expires_at = SystemTime::now() + Duration::from_secs(response.expires_in);
        }

        &self.access_token
    }
}

impl<'a> Reddit<'a> {
    /// Get a URL to send the user to for authentication.
    pub fn get_auth_url(&self, callback: &str) -> Result<String, UrlError> {
        Ok(Url::parse_with_params(
            "https://ssl.reddit.com/api/v1/authorize",
            &[
                ("response_type", "code"),
                ("client_id", self.client_id),
                ("state", callback),
                ("redirect_uri", self.redirect_uri),
                (
                    "duration",
                    if self.permanent {
                        "permanent"
                    } else {
                        "temporary"
                    },
                ),
                ("scope", &self.scopes().iter().join(" ")),
            ],
        )?
        .into_string())
    }

    /// Given a code, obtain a refresh token from Reddit.
    pub fn obtain_refresh_token(&self, code: &str) -> reqwest::Result<User<'_>> {
        ApiReturnType! {
            access_token: String,
            expires_in: u64,
            refresh_token: Option<String>,
        };

        let data: ApiReturnType = CLIENT
            .post("https://ssl.reddit.com/api/v1/access_token")
            .basic_auth(self.client_id, Some(self.secret))
            .form(&[
                ("grant_type", "authorization_code"),
                ("code", code),
                ("redirect_uri", self.redirect_uri),
            ])
            .send()?
            .json()?;

        Ok(User {
            reddit_instance: self,
            refresh_token:   data.refresh_token.unwrap(),
            access_token:    data.access_token,
            expires_at:      SystemTime::now() + Duration::from_secs(data.expires_in),
        })
    }
}

/// Reduce repetition by using a macro.
/// This also creates a more readable method,
/// as it reads like plain English.
macro_rules! request {
    (send nothing to $endpoint:literal using $_self:ident) => {
        CLIENT
            .get(concat!("https://oauth.reddit.com", $endpoint))
            .header(USER_AGENT, $_self.reddit_instance.user_agent)
            .bearer_auth($_self.access_token())
            .send()
    };

    (
        send {
            $($key:expr => $value:expr),+ $(,)?
        }
        to $endpoint:literal
        using $_self:ident
    ) => {
        CLIENT
            .get(concat!("https://oauth.reddit.com", $endpoint))
            .header(USER_AGENT, $_self.reddit_instance.user_agent)
            .bearer_auth($_self.access_token())
            .form(&[$(($key, $value),)*])
            .send()
    };
}

/// Endpoints
impl User<'_> {
    fn me(&mut self) -> reqwest::Result<reqwest::Response> {
        request! { send nothing to "/api/v1/me" using self }
    }

    fn prefs(&mut self) -> reqwest::Result<reqwest::Response> {
        request! { send nothing to "/api/v1/me/prefs" using self }
    }

    fn submit(
        &mut self,
        subreddit: &str,
        title: &str,
        text: Option<&str>,
    ) -> reqwest::Result<reqwest::Response> {
        request! {
            send {
                "kind" => "self",
                "api_type" => "json",
                "extensions" => "json",
                "sendreplies" => "false",
                "sr" => subreddit,
                "title" => title,
                "text" => text.unwrap_or_default(),
            }
            to "/api/submit"
            using self
        }
    }

    fn edit(&mut self, thing_id: &str, text: &str) -> reqwest::Result<reqwest::Response> {
        request! {
            send {
                "api_type" => "json",
                "thing_id" => thing_id,
                "text" => text,
            }
            to "/api/editusertext"
            using self
        }
    }

    fn approve_internal(&mut self, thing_id: &str) -> reqwest::Result<reqwest::Response> {
        request!(send { "id" => thing_id } to "/api/approve" using self)
    }

    fn set_sticky_internal(
        &mut self,
        thing_id: &str,
        state: bool,
    ) -> reqwest::Result<reqwest::Response> {
        request! {
            send {
                "api_type" => "json",
                "id" => thing_id,
                "state" => &state.to_string(),
            }
            to "/api/set_subreddit_sticky"
            using self
        }
    }
}

/// Methods that use endpoints
impl User<'_> {
    /// Get a user's username on Reddit.
    pub fn username(&mut self) -> reqwest::Result<String> {
        ApiReturnType! { name: String };
        Ok(self.me()?.json::<ApiReturnType>()?.name)
    }

    /// Get a user's language preference.
    pub fn lang(&mut self) -> reqwest::Result<String> {
        ApiReturnType! { lang: String };
        Ok(self.prefs()?.json::<ApiReturnType>()?.lang)
    }

    /// Submit a post on Reddit with a given title and body.
    /// Returns the `thing_id`.
    pub fn submit_self_post(
        &mut self,
        subreddit: &str,
        title: &str,
        text: Option<&str>,
    ) -> reqwest::Result<String> {
        Ok(self
            .submit(subreddit, title, text)?
            .json::<serde_json::Value>()?
            .get("json")
            .unwrap()
            .get("data")
            .unwrap()
            .get("id")
            .unwrap()
            .to_string())
    }

    /// Edit an existing thread on Reddit.
    pub fn edit_self_post(&mut self, thing_id: &str, text: &str) -> reqwest::Result<()> {
        self.edit(thing_id, text).map(|_| ())
    }

    /// Approve a thread on Reddit.
    pub fn approve(&mut self, thing_id: &str) -> reqwest::Result<()> {
        self.approve_internal(thing_id).map(|_| ())
    }

    /// Sticky or unsticky a thread on Reddit.
    pub fn set_sticky(&mut self, thing_id: &str, state: bool) -> reqwest::Result<()> {
        self.set_sticky_internal(thing_id, state).map(|_| ())
    }
}
